
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <android/bitmap.h> //【导入】
#include <android/log.h>
#include <stdlib.h>
#include <math.h>

/* Header for class com_move_bitmaplib_Filter */

#ifndef _Included_com_move_bitmaplib_Bitmaplib
#define _Included_com_move_bitmaplib_Bitmaplib

#define LOG_TAG "bitmaplib"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)

#define RGBA_A(p) (((p) >> 24) & 0x000000FF)
#define RGBA_R(p) (((p) >> 16) & 0x000000FF)
#define RGBA_G(p) (((p) >> 8) & 0x000000FF)
#define RGBA_B(p)  ((p) & 0x000000FF)
#define MAKE_RGBA(r, g, b, a) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b))


typedef jobject jbitmap;

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    gray
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_gray
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    void *pixels;//图片地址
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int a = 0, r = 0, g = 0, b = 0;
    uint32_t *pixel = NULL;

    // From top to bottom
    for (y = 0; y < info.height; ++y) {
        // From left to right
        for (x = 0; x < info.width; ++x) {

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + y * info.width + x;

            uint32_t v = *pixel;
            a = RGBA_A(v);
            r = RGBA_R(v);
            g = RGBA_G(v);
            b = RGBA_B(v);

            // Grayscale
            int gray = (r * 38 + g * 75 + b * 15) >> 7;

            // Write the pixel back
            // RGBA
            *(pixel) = MAKE_RGBA(gray, gray, gray, a);

        }
    }

    pixel = NULL;

    AndroidBitmap_unlockPixels(env, jbit);


}

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    mosaic
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_mosaic
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    void *pixels;//图片地址
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int a = 0, r = 0, g = 0, b = 0;
    uint32_t *prePixel = NULL;
    uint32_t *pixel = NULL;

    int mosaic = 5;
    int offset = mosaic / 2;
    int newX, newY;

    // From top to bottom
    for (y = 0; y < info.height; ++y) {
        // From left to right
        for (x = 0; x < info.width; ++x) {

            // Get each pixel by format
            newX = x - (x % mosaic - offset);
            newY = y - (y % mosaic - offset);

            // 指针的移动,获取到当前这个像素点的指针
            prePixel = ((uint32_t *) pixels) + newY * info.width + newX;

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + y * info.width + x;

            *pixel = *prePixel;

        }
    }

    prePixel = NULL;
    pixel = NULL;

    AndroidBitmap_unlockPixels(env, jbit);


}


//===========================pencli============================start

int *getGray(void *pixels, int width, int height) {

    int size = width * height;

    LOGE("====================size============%d", size);

    int *gray_p = (int *) malloc(sizeof(int) * size);
    int index = -1;

    int r = 0, g = 0, b = 0;
    uint32_t *pixel = NULL;

    for (int i = 0; i < width - 1; i++) {
        for (int j = 0; j < height - 1; j++) {

            // get the index of pixels
            index = j * width + i;

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + index;

            uint32_t v = *pixel;
            r = RGBA_R(v) * 3;
            g = RGBA_G(v) * 6;
            b = RGBA_B(v);

            gray_p[index] = (r + g + b) / 10;

        }
    }

    return gray_p;

}

int *getInverse(int *gray, int width, int height) {

    int size = width * height;

    int *inverse = (int *) malloc(sizeof(int) * size);

    for (int i = 0; i < size; ++i) {
        inverse[i] = 255 - gray[i];
    }

    return inverse;

}

int *getGuassBlur(int *inverse, int width, int height) {

    int size = width * height;

    int *guassBlur = (int *) malloc(sizeof(int) * size);

    int index = -1;
    int i0;
    int i1;
    int i2;
    int i3;
    int i4;
    int i5;
    int i6;
    int i7;
    int i8;
    int sum;

    for (int i = 0; i < width; ++i) {
        for (int j = 0; j < height; ++j) {
            index = j * width + i;
            if ((i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)) {
                guassBlur[index] = 0;
            } else {

                i0 = width * (j - 1) + (i - 1);
                i1 = width * (j - 1) + (i);
                i2 = width * (j - 1) + (i + 1);
                i3 = width * (j) + (i - 1);
                i4 = width * (j) + (i);
                i5 = width * (j) + (i + 1);
                i6 = width * (j + 1) + (i - 1);
                i7 = width * (j + 1) + (i);
                i8 = width * (j + 1) + (i + 1);

                sum = inverse[i0] + 2 * inverse[i1] +
                      inverse[i2] + 2 * inverse[i3] +
                      4 * inverse[i4] + 2 * inverse[i5] +
                      inverse[i6] + 2 * inverse[i7] + inverse[i8];
                sum /= 16;
                guassBlur[index] = sum;

            }
        }
    }

    return guassBlur;

}

int *getDeceasecolorCompound(int *guassBlur, int *gray, int width, int height) {

    int size = width * height;

    int *deceasecolorCompound = (int *) malloc(sizeof(int) * size);

    int index = -1;
    int a, b, temp;
    float ex;

    for (int i = 0; i < width; ++i) {
        for (int j = 0; j < height; ++j) {
            index = j * width + i;
            b = guassBlur[index];
            a = gray[index];

            temp = a + a * b / (256 - b);
            ex = temp * temp * 1.0f / 255 / 255;
            temp = (int) (temp * ex);

            a = fminf(temp, 255);

            deceasecolorCompound[index] = a;

        }
    }

    return deceasecolorCompound;

}

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    pencli
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_pencli
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    // this point point to first pixels of all
    void *pixels;
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int *gray = getGray(pixels, info.width, info.height);

    int *inverse = getInverse(gray, info.width, info.height);

    int *guassBlur = getGuassBlur(inverse, info.width, info.height);

    int *deceasecolorCompound = getDeceasecolorCompound(guassBlur, gray, info.width, info.height);

    int size = info.width * info.height;
    int index = -1;
    int pixel;

    for (int i = 0; i < info.width; ++i) {
        for (int j = 0; j < info.height; ++j) {
            index = j * info.width + i;
            uint32_t *p = ((uint32_t *) pixels) + index;
            int gray = deceasecolorCompound[index];
            if (i <= 0 || i >= info.width - 1 || j <= 0 || j >= info.height - 1) {
                pixel = 0x00000000 | (gray << 16) | (gray << 8) |
                        gray; // 注意加上原图的 alpha通道
            } else {
                pixel = (*p & 0xff000000) | (gray << 16) | (gray << 8) |
                        gray; // 注意加上原图的 alpha通道
            }
            *p = pixel;

        }
    }

//    for (int i = 0; i < size; i++) {
//        int gray = deceasecolorCompound[i];
//        uint32_t *p = ((uint32_t *) pixels) + i;
//        pixel = (*p & 0xFF000000) | (gray << 16) | (gray << 8) |
//                gray; //注意加上原图的 alpha通道
//        *p = pixel;
//    }

    free(gray);
    free(inverse);
    free(guassBlur);
    free(deceasecolorCompound);

    AndroidBitmap_unlockPixels(env, jbit);


}

//===========================pencli============================end

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    nostalgia
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_nostalgia
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    void *pixels;//图片地址
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int a = 0, r = 0, g = 0, b = 0;
    uint32_t *pixel = NULL;

    // From top to bottom
    for (y = 0; y < info.height; ++y) {
        // From left to right
        for (x = 0; x < info.width; ++x) {

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + y * info.width + x;

            uint32_t color = *pixel;

            a = RGBA_A(color);
            r = RGBA_R(color);
            g = RGBA_G(color);
            b = RGBA_B(color);

            r = fmin(floor((0.343 * r + 0.719 * g + 0.139 * b)), 255);
            g = fmin(floor((0.299 * r + 0.636 * g + 0.118 * b)), 255);
            b = fmin(floor((0.222 * r + 0.484 * g + 0.081 * b)), 255);

            *pixel = MAKE_RGBA(r, g, b, a);

        }
    }

    pixel = NULL;

    AndroidBitmap_unlockPixels(env, jbit);


}

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    relief
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_relief
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    void *pixels;//图片地址
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int a = 0, r = 0, g = 0, b = 0;
    uint32_t *pixel = NULL;

    // From top to bottom
    for (y = 0; y < info.height - 1; ++y) {
        // From left to right
        for (x = 0; x < info.width - 1; ++x) {

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + y * info.width + x;

            uint32_t color = *pixel;

            a = RGBA_A(color);
            r = RGBA_R(color);
            g = RGBA_G(color);
            b = RGBA_B(color);

            color = *(pixel + 1);

            r = RGBA_R(color) - r + 127;
            g = RGBA_G(color) - g + 127;
            b = RGBA_B(color) - b + 127;

            r = fmin(fmax(r, 0), 255);
            g = fmin(fmax(g, 0), 255);
            b = fmin(fmax(b, 0), 255);

            *pixel = MAKE_RGBA(r, g, b, 255);

        }
    }

    pixel = NULL;

    AndroidBitmap_unlockPixels(env, jbit);


}

/*
 * Class:     com_move_bitmaplib_Filter
 * Method:    filmAmeliorate
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_move_bitmaplib_Filter_filmAmeliorate
        (JNIEnv *env, jclass jc, jbitmap jbit) {

    AndroidBitmapInfo info;//AndroidBitmapInfo图片信息
    void *pixels;//图片地址
    AndroidBitmapInfo infogray;
    void *pixelsgray;
    int ret;
    int y;
    int x;

    ret = AndroidBitmap_getInfo(env, jbit, &info);
    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    LOGE("width :%d,height :%d", info.width, info.height);

    ret = AndroidBitmap_lockPixels(env, jbit, &pixels);

    if (ret != ANDROID_BITMAP_RESULT_SUCCESS) {
        return;
    }

    int a = 0, r = 0, g = 0, b = 0,max_value = 255;
    uint32_t *pixel = NULL;

    // From top to bottom
    for (y = 0; y < info.height - 1; ++y) {
        // From left to right
        for (x = 0; x < info.width - 1; ++x) {

            // 指针的移动,获取到当前这个像素点的指针
            pixel = ((uint32_t *) pixels) + y * info.width + x;

            uint32_t color = *pixel;

            a = RGBA_A(color);
            r = RGBA_R(color);
            g = RGBA_G(color);
            b = RGBA_B(color);

            color = *(pixel + 1);

            r = max_value - r;
            g = max_value - g;
            b = max_value - b;

            r = fmin(fmax(r, 0), 255);
            g = fmin(fmax(g, 0), 255);
            b = fmin(fmax(b, 0), 255);

            *pixel = MAKE_RGBA(r, g, b, 255);

        }
    }

    pixel = NULL;

    AndroidBitmap_unlockPixels(env, jbit);


}

#endif
